// The world is generated by using Perlin noise (https://en.wikipedia.org/wiki/Perlin_noise)
let generationID = 0;
async function generateWorld() {

    let start = Date.now();

    // Generation ID (used to cancel simultaneous/outdated generation)
    generationID++;
    let currentGenerationID = generationID;

    // Zoom is capped at 1000 to avoid lag
    // So in order to zoom out more, we reduce Perlin noise's frequency
    // Default frequency is 120
    let zoomLevel = zoom > settings.resolutionCap ? zoom / settings.resolutionCap : 1;
    let frequency = 120 / zoomLevel;
    let cappedZoom = zoom > settings.resolutionCap ? settings.resolutionCap : zoom;

    // Update world height & center values
    worldHeight = canvas.height / (canvas.width / cappedZoom); // Capped world height
    let uncappedWorldHeight = canvas.height / (canvas.width / zoom);

    [centerWidth, centerHeight] = [Math.round(zoom / 2), Math.round(uncappedWorldHeight / 2)];
    let squareSide = canvas.width / cappedZoom;

    /**
     * STEP 1: Generate ocean map
     * Ocean value ranges from 0 to 100
     */
    let oceanMap = [];
    for (let wX = 0; wX < cappedZoom; wX++) {
        oceanMap[wX] = [];
        for (let wY = 0; wY < worldHeight; wY++) {

            // Get Perlin noise value
            let noiseValue = noise.perlin2(
                (((x - centerWidth) / zoomLevel) + wX) / (frequency * 10),
                (((y - centerHeight) / zoomLevel) + wY) / (frequency * 10)

            );

            let oceanValue = Math.round((noiseValue + 1) * 50);
            oceanMap[wX][wY] = oceanValue;

        }
    }

    // Check if generation is outdated
    if (currentGenerationID != generationID) return;

    /**
     * STEP 2: Generate heightmap
     * Max height is 5000
     * Ocean height is 0
     */
    let heightmap = [];
    for (let wX = 0; wX < cappedZoom; wX++) {
        heightmap[wX] = [];
        for (let wY = 0; wY < worldHeight; wY++) {

            // Get Perlin noise value
            let noiseValue = noise.perlin2(
                (((x - centerWidth) / zoomLevel) + wX) / (frequency * 3),
                (((y - centerHeight) / zoomLevel) + wY) / (frequency * 3)
            );

            let height = Math.round(((noiseValue + 1) * 2500) - (oceanMap[wX][wY] * 60))
            heightmap[wX][wY] = height;

        }
    }

    // Check if generation is outdated
    if (currentGenerationID != generationID) return;

    /**
     * STEP 3: Generate forest map
     */
    let forestMap = [];
    for (let wX = 0; wX < cappedZoom; wX++) {
        forestMap[wX] = [];
        for (let wY = 0; wY < worldHeight; wY++) {

            // Get Perlin noise value
            let noiseValue = noise.perlin2(
                (((x - centerWidth) / zoomLevel) + wX) / (frequency),
                (((y - centerHeight) / zoomLevel) + wY) / (frequency)
            );

            let forestValue = Math.round((noiseValue + 1) * 50) - (oceanMap[wX][wY] * 0.7) - (heightmap[wX][wY] / 50);
            forestMap[wX][wY] = forestValue;

        }
    }

    // Check if generation is outdated
    if (currentGenerationID != generationID) return;

    /**
     * STEP 3: Draw world
     */
    for (let wX = 0; wX < cappedZoom; wX++) {
        for (let wY = 0; wY < worldHeight; wY++) {

            // Get world data
            let [height, ocean, forest] = [heightmap[wX][wY], oceanMap[wX][wY], forestMap[wX][wY]];

            // Get biome
            let biome;
            if (ocean >= 60)
                biome = oceans.find(o => o.isInRange(ocean));

            else if (forest > 40)
                biome = forests.find(f => f.isInRange(forest));

            else
                biome = land.find(land => land.isInRange(height));

            if (biome == undefined) console.log({ height, ocean });

            // Draw tile
            ctx.fillStyle = biome.color;

            if (wX == Math.round(cappedZoom / 2) && wY == Math.round(worldHeight / 2)) {
                updateBiomeInfo(biome);
                ctx.fillStyle = "#ff0000";
            }
            ctx.fillRect(wX * squareSide, wY * squareSide, squareSide + 1, squareSide + 1);

        }

        // If zoom is too high, render "chunks" of the world at a time (to avoid crash)
        if (cappedZoom >= 1000 && wX % 100 == 0) {
            await new Promise(r => setTimeout(r, 0));
        }

        // Check if generation is outdated
        if (currentGenerationID != generationID) return;

    }

    // Update Refresh rate
    updateRefreshRate(1000 / (Date.now() - start));

    // Update pixel count
    document.getElementById('pixelCount').innerHTML = Math.ceil(cappedZoom * worldHeight) + (zoomLevel > 1 ? ' (capped!)' : '');

}

// Biome
class Biome {
    constructor(name, color, dataRange) {
        this.name = name;
        this.color = color;
        this.dataRange = dataRange;
    }

    isInRange(value) {
        return this.dataRange.isInRange(value);
    }
}

class Range {
    constructor(min, max) {
        this.min = (min === true) ? -Infinity : min;
        this.max = (max === true) ? Infinity : max;
    }

    isInRange(value) {
        return value >= this.min && value <= this.max;
    }
}

const oceans = [
    new Biome("abyss", "#252a5c", new Range(95, true)),
    new Biome("deepOcean", "#30377a", new Range(84, 95)),
    new Biome("ocean", "#4952ad", new Range(71, 84)),
    new Biome("coast", "#5670c4", new Range(61, 71)),
    new Biome("beach", "#dade71", new Range(60, 61)),
    new Biome("void", "#000000", new Range(true, true))
]

const land = [
    new Biome("grass", "#62b05a", new Range(true, 1000)),
    new Biome("mountain", "#d1c6b2", new Range(1000, 1500)),
    new Biome("subalpine", "#ded4c1", new Range(1500, 2000)),
    new Biome("alpine", "#ebe2d1", new Range(2000, 2500)),
    new Biome("snow", "#f7f0e1", new Range(2500, true)),
    new Biome("void", "#000000", new Range(true, true))
]

const forests = [
    new Biome("vegetation", "#589c51", new Range(true, 50)),
    new Biome("forest", "#437d3d", new Range(50, 70)),
    new Biome("denseForest", "#34662f", new Range(70, true)),
]